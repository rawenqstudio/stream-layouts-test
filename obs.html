<!DOCTYPE html>
<html lang="pl">
  <head>
    <meta charset="UTF-8" />
    <title>WIDOK OBS</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
      body,
      html {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        background: transparent;
        font-family: "Segoe UI", sans-serif;
      }

      #video-container {
        width: 100%;
        height: 100%;
        transition: all 0.5s ease;
        position: relative;
      }

      .video-box {
        position: relative;
        overflow: hidden;
        border: 2px solid white;
        box-shadow: 0 0 15px rgba(0, 0, 0, 0.7);
        background: #000;
        transition: all 0.5s ease;
      }

      video {
        width: 100%;
        height: 100%;
        object-fit: cover;
        display: block;
      }
      video.mirror-effect {
        transform: scaleX(-1);
      }

      .mute-icon {
        position: absolute;
        top: 10px;
        right: 10px;
        color: red;
        font-size: 24px;
        background: rgba(0, 0, 0, 0.5);
        padding: 5px;
        border-radius: 50%;
        display: none;
        z-index: 20;
      }
      .label {
        position: absolute;
        bottom: 10px;
        left: 10px;
        background: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 5px 15px;
        border-radius: 4px;
        font-size: 1.2rem;
        font-weight: bold;
        text-shadow: 1px 1px 2px black;
        border-left: 4px solid #00d2ff;
        z-index: 10;
        display: none;
      }

      #video-container:not(.show-labels) .label {
        display: none !important;
      }
      #video-container:not(.show-icons) .mute-icon {
        display: none !important;
      }

      /* UK≈ÅADY */
      .layout-grid {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        align-content: center;
        gap: 15px;
        padding: 20px;
        box-sizing: border-box;
      }
      .layout-grid .video-box {
        width: 45%;
        height: 45%;
      }
      .layout-grid[data-count="1"] .video-box {
        width: 85%;
        height: 85%;
      }
      .layout-grid[data-count="2"] .video-box {
        width: 48%;
        height: 60%;
      }
      .layout-grid[data-count="3"] .video-box,
      .layout-grid[data-count="4"] .video-box {
        width: 45%;
        height: 45%;
      }
      .layout-grid[data-count="5"] .video-box,
      .layout-grid[data-count="6"] .video-box {
        width: 32%;
        height: 45%;
      }
      .layout-grid[data-count="7"] .video-box,
      .layout-grid[data-count="8"] .video-box,
      .layout-grid[data-count="9"] .video-box {
        width: 32%;
        height: 30%;
      }
      .layout-grid[data-count="10"] .video-box,
      .layout-grid[data-count="11"] .video-box,
      .layout-grid[data-count="12"] .video-box {
        width: 23%;
        height: 23%;
      }

      .layout-sidebar-right {
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: flex-end;
        padding-right: 20px;
        height: 100vh;
        box-sizing: border-box;
      }
      .layout-sidebar-right .video-box {
        width: 320px;
        height: 180px;
        margin-bottom: 15px;
      }
      .layout-sidebar-left {
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: flex-start;
        padding-left: 20px;
        height: 100vh;
        box-sizing: border-box;
      }
      .layout-sidebar-left .video-box {
        width: 320px;
        height: 180px;
        margin-bottom: 15px;
      }
      .layout-bottom {
        display: flex;
        flex-direction: row;
        justify-content: center;
        align-items: flex-end;
        padding-bottom: 20px;
        height: 100vh;
        box-sizing: border-box;
      }
      .layout-bottom .video-box {
        width: 280px;
        height: 157px;
        margin: 0 10px;
      }
      .layout-top {
        display: flex;
        flex-direction: row;
        justify-content: center;
        align-items: flex-start;
        padding-top: 20px;
        height: 100vh;
        box-sizing: border-box;
      }
      .layout-top .video-box {
        width: 280px;
        height: 157px;
        margin: 0 10px;
      }

      /* SPLIT - Naprawiony */
      .layout-split {
        display: grid;
        grid-template-columns: 320px 1fr 320px;
        grid-auto-rows: min-content;
        align-content: center;
        row-gap: 30px;
        padding: 20px 40px;
        height: 100vh;
        box-sizing: border-box;
      }
      .layout-split .video-box {
        width: 100%;
        height: 180px;
        margin: 0;
      }
      .layout-split .video-box:nth-child(odd) {
        grid-column: 1;
        justify-self: start;
      }
      .layout-split .video-box:nth-child(even) {
        grid-column: 3;
        justify-self: end;
      }

      /* CENTER STAGE */
      .layout-center-stage {
        display: grid;
        grid-template-columns: 300px 1fr 300px;
        grid-auto-rows: min-content;
        gap: 15px;
        padding: 20px;
        height: 100vh;
        box-sizing: border-box;
        align-content: center;
      }
      .layout-center-stage .video-box {
        width: 100%;
        height: 169px;
        margin: 0;
      }
      .layout-center-stage .video-box:nth-child(1) {
        grid-column: 2;
        grid-row: 1 / span 10;
        width: 100%;
        height: auto;
        max-height: 90vh;
        aspect-ratio: 16/9;
        align-self: center;
        z-index: 10;
        box-shadow: 0 0 30px rgba(0, 0, 0, 0.8);
      }
      .layout-center-stage .video-box:nth-child(even) {
        grid-column: 1;
      }
      .layout-center-stage .video-box:nth-child(odd):not(:first-child) {
        grid-column: 3;
      }
    </style>
  </head>
  <body>
    <div id="video-container" class="layout-grid" data-count="0"></div>

    <script>
      const urlParams = new URLSearchParams(window.location.search);
      const myID = urlParams.get("room") || "test-room";
      const useStunOnly = urlParams.get("stunonly");
      const useULL = urlParams.get("ull");
      const isMulti = urlParams.get("multi");

      const selectedConfig = useStunOnly
        ? [{ urls: "stun:stun.l.google.com:19302" }]
        : [
            { urls: "stun:stun.l.google.com:19302" },
            {
              urls: "turn:openrelay.metered.ca:80?transport=udp",
              username: "openrelayproject",
              credential: "openrelayproject",
            },
            {
              urls: "turn:openrelay.metered.ca:80?transport=tcp",
              username: "openrelayproject",
              credential: "openrelayproject",
            },
            {
              urls: "turn:openrelay.metered.ca:443?transport=udp",
              username: "openrelayproject",
              credential: "openrelayproject",
            },
            {
              urls: "turn:openrelay.metered.ca:443?transport=tcp",
              username: "openrelayproject",
              credential: "openrelayproject",
            },
          ];

      const peer = new Peer(isMulti ? undefined : myID, {
        config: { iceServers: selectedConfig },
      });
      const container = document.getElementById("video-container");

      const guests = {};
      const heartbeats = {};
      let directorConn = null;
      const statsCache = {};

      peer.on("open", (id) => {
        console.log("OBS gotowy. ID: " + id);
        if (isMulti) connectToDirector(myID);
      });

      function connectToDirector(targetId) {
        directorConn = peer.connect(targetId);
        directorConn.on("open", () => {
          console.log("Po≈ÇƒÖczono z Re≈ºyserem.");
          directorConn.send({ type: "register-obs" });
        });
        directorConn.on("data", (data) => handleData(data));
      }

      peer.on("call", (call) => {
        call.answer();
        if (!guests[call.peer])
          guests[call.peer] = {
            name: "≈ÅƒÖczenie...",
            muted: false,
            mirrored: false,
            conn: null,
          };
        guests[call.peer].call = call;

        if (useULL) {
          setTimeout(() => {
            const pc = call.peerConnection;
            if (pc && pc.getReceivers) {
              pc.getReceivers().forEach((receiver) => {
                if (
                  receiver.track &&
                  receiver.track.kind === "video" &&
                  "playoutDelayHint" in receiver
                ) {
                  receiver.playoutDelayHint = 0;
                }
              });
            }
          }, 500);
        }

        call.on("stream", (stream) => addVideo(stream, call.peer));
        call.on("close", () => removeGuest(call.peer));
        call.on("error", () => removeGuest(call.peer));

        const pc = call.peerConnection;
        pc.oniceconnectionstatechange = () => {
          const s = pc.iceConnectionState;
          if (s === "disconnected" || s === "failed" || s === "closed")
            removeGuest(call.peer);
        };
      });

      peer.on("connection", (conn) => {
        conn.on("data", (data) => {
          if (data.type === "director-hello") {
            directorConn = conn;
            sendGuestListToDirector();
          }
          handleData(data, conn);
        });
        conn.on("close", () => removeGuest(conn.peer));
        conn.on("error", () => removeGuest(conn.peer));
      });

      function handleData(data, conn) {
        if (data.type === "layout") container.className = data.mode;

        if (data.type === "toggle-labels") {
          if (data.show) container.classList.add("show-labels");
          else container.classList.remove("show-labels");
        }
        if (data.type === "toggle-icons") {
          if (data.show) container.classList.add("show-icons");
          else container.classList.remove("show-icons");
        }

        // --- POPRAWKA: FIZYCZNA ZMIANA KOLEJNO≈öCI DOM ---
        if (data.type === "reorder-guests") {
          const orderList = data.order;
          orderList.forEach((id) => {
            const box = document.getElementById(`box-${id}`);
            if (box) {
              // appendChild przenosi istniejƒÖcy element na koniec
              // Dziƒôki pƒôtli forEach u≈Ço≈ºymy je w kolejno≈õci z tablicy
              container.appendChild(box);
            }
          });
        }
        // ------------------------------------------------

        if (data.type === "refresh-cam") {
          if (data.targetId === "all")
            Object.keys(guests).forEach((id) => performRefresh(id));
          else performRefresh(data.targetId);
        }

        if (data.type === "toggle-mirror") {
          const id = data.targetId;
          const box = document.getElementById(`box-${id}`);
          if (box) {
            const video = box.querySelector("video");
            if (video) {
              video.classList.toggle("mirror-effect");
              if (guests[id])
                guests[id].mirrored = video.classList.contains("mirror-effect");
              sendGuestListToDirector();
            }
          }
        }

        if (data.type === "remote-mute") {
          if (guests[data.targetId] && guests[data.targetId].conn) {
            guests[data.targetId].conn.send({
              type: "mute-cmd",
              state: data.state,
            });
          }
        }
        if (data.type === "identify" && conn) {
          if (!guests[conn.peer])
            guests[conn.peer] = { name: "Go≈õƒá", muted: false, mirrored: false };
          guests[conn.peer].name = data.name || "Go≈õƒá";
          guests[conn.peer].conn = conn;
          updateLabel(conn.peer, data.name);
          sendGuestListToDirector();
        }
        if (data.type === "mic-status" && conn) {
          if (guests[conn.peer]) {
            guests[conn.peer].muted = data.muted;
            toggleMuteIcon(conn.peer, data.muted);
            sendGuestListToDirector();
          }
        }
        if (data.type === "heartbeat" && conn)
          heartbeats[conn.peer] = Date.now();
        if (data.type === "leave" && conn) removeGuest(conn.peer);
      }

      function updateGuestCount() {
        const count = container.querySelectorAll(".video-box").length;
        container.setAttribute("data-count", count);
      }

      function addVideo(stream, id) {
        if (document.getElementById(`box-${id}`)) return;
        heartbeats[id] = Date.now();
        statsCache[id] = 0;

        const box = document.createElement("div");
        box.className = "video-box";
        box.id = `box-${id}`;
        // Usuniƒôto style.order, bo teraz polegamy na DOM

        const video = document.createElement("video");
        video.srcObject = stream;
        video.muted = true;
        video.autoplay = true;
        video.playsInline = true;

        const audio = document.createElement("audio");
        audio.srcObject = stream;
        audio.muted = false;
        audio.autoplay = true;
        audio.id = `audio-${id}`;

        const label = document.createElement("div");
        label.className = "label";
        label.id = `label-${id}`;

        const muteIcon = document.createElement("div");
        muteIcon.className = "mute-icon";
        muteIcon.innerText = "üîá";
        muteIcon.id = `mute-${id}`;

        box.appendChild(video);
        box.appendChild(label);
        box.appendChild(muteIcon);
        box.appendChild(audio);
        container.appendChild(box);

        updateGuestCount();

        video.play().catch((e) => console.error(e));
        audio.play().catch((e) => console.warn(e));
      }

      function removeGuest(id) {
        if (document.getElementById(`box-${id}`)) {
          document.getElementById(`box-${id}`).remove();
          delete guests[id];
          delete heartbeats[id];
          delete statsCache[id];
          updateGuestCount();
          sendGuestListToDirector();
        }
      }

      setInterval(async () => {
        const now = Date.now();
        const statsReport = {};
        for (const peerId in guests) {
          if (heartbeats[peerId] && now - heartbeats[peerId] > 7000) {
            removeGuest(peerId);
            continue;
          }
          const guest = guests[peerId];
          if (guest.call && guest.call.peerConnection) {
            try {
              const stats = await guest.call.peerConnection.getStats();
              let videoStats = null;
              stats.forEach((report) => {
                if (report.type === "inbound-rtp" && report.kind === "video")
                  videoStats = report;
              });
              if (videoStats) {
                const bytes = videoStats.bytesReceived;
                const prevBytes = statsCache[peerId] || 0;
                const bitrate = ((bytes - prevBytes) * 8) / 1000;
                statsCache[peerId] = bytes;
                statsReport[peerId] = {
                  bitrate: Math.round(bitrate),
                  packetLoss: videoStats.packetsLost || 0,
                  resolution:
                    videoStats.frameWidth && videoStats.frameHeight
                      ? `${videoStats.frameWidth}x${videoStats.frameHeight}`
                      : "N/A",
                };
              }
            } catch (e) {}
          }
        }
        if (
          directorConn &&
          directorConn.open &&
          Object.keys(statsReport).length > 0
        ) {
          directorConn.send({ type: "stats-update", stats: statsReport });
        }
      }, 1000);

      function performRefresh(id) {
        const box = document.getElementById(`box-${id}`);
        if (!box) return;
        const video = box.querySelector("video");
        const audio = box.querySelector("audio");
        if (video && video.srcObject) {
          const stream = video.srcObject;
          video.srcObject = null;
          if (audio) audio.srcObject = null;
          setTimeout(() => {
            video.srcObject = stream;
            if (audio) audio.srcObject = stream;
            video.play().catch((e) => console.log(e));
            if (audio) audio.play().catch((e) => console.log(e));
          }, 100);
        }
      }

      function updateLabel(id, name) {
        const label = document.getElementById(`label-${id}`);
        if (label) {
          if (name && name.trim() !== "") {
            label.innerText = name;
            label.style.display = "block";
          } else {
            label.style.display = "none";
          }
        }
      }

      function toggleMuteIcon(id, isMuted) {
        const icon = document.getElementById(`mute-${id}`);
        if (icon) icon.style.display = isMuted ? "block" : "none";
      }

      function sendGuestListToDirector() {
        if (directorConn && directorConn.open) {
          const safeList = Object.keys(guests).map((id) => ({
            id: id,
            name: guests[id].name,
            muted: guests[id].muted,
            mirrored: guests[id].mirrored,
          }));
          directorConn.send({ type: "guest-list", list: safeList });
        }
      }
    </script>
  </body>
</html>
